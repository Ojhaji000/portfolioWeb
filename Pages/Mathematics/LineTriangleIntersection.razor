@page "/mathematics/lineTriangleIntersection"

<PageTitle>Mathematics</PageTitle>

<!-- Header -->
<section class="hero">
    <h1>Line-Triangle Intersection</h1>
    <p class="subtitle">
        checking intersection between items in 3D space
    </p>
    <p class="publish-date">
        Published on: <strong>04 January 2026</strong>
    </p>

    <div class="tags">
        <span>C++</span>
        <span>Coordinate Geometry</span>
    </div>
</section>

<!-- Problem Statement -->
<section class="section">
    <h2>Problem Statement</h2>
    <p>
        In 3D space, checking whether a line and a triangle are intersecting each other or not
    </p>
</section>

<!-- Mathematical Foundation -->
<section class="section">
    <h2>Mathematical Foundation</h2>
    <p>
        IT IS done in different stages:
        <br>1. two inputs: line and triangle
        <br>1.1 line contains, origin(a.k.a. point on line and direction vector of the line)
        <br>1.2 triangle:  3 points containing x,y,z each
        <br>2. then we find the pplane containing the points of triangle
        <br>3. find the intersection of line and plane, results in point
        <br>4. check the point is insided the triangle or not, through area method
    </p>
    <pre class="math">
<strong>Line equation in vector form:</strong>
r = r' + t·dir
where <strong>r'</strong> is origin of line, <strong>dir</strong> is line's direction, <strong>t</strong> is a constant
<strong>Plane equation:</strong>
n · (p - p') = 0
where <strong>n</strong> is normal of the plane, <strong>p'</strong> is the point in the plane
<strong>Solving for t:</strong>
t = (n · (p' - r')) / (n · d)
        @* E = mc<sup>2</sup>
        a<sub>1</sub> + a<sub>2</sub> = b
        x<sup>2</sup> + y<sup>2</sup> = z<sup>2</sup> *@

    </pre>
</section>

<!-- Visual Demonstration -->
<section class="section">
    <h2>Visual Demonstration</h2>
        <div class="desmos-container">
            <iframe src="https://www.desmos.com/3d/y0jgxhqcxp"
                    allowfullscreen>
            </iframe>
        </div>
</section>


<!-- Code Mapping -->
<section class="section">
    <h2>Code Mapping</h2>
    <p>
        The following shows a short summary of the code logic.
    </p>

    <!-- Short code snippet -->
    <pre class="code">
        custom datatypes ->{for making or representing the points,
                            3d vectors, line, plane, etc }

        Plane planeOfTriangle = Utility::PlaneOfTriangle(trianglePoints) 
                            -> to find the plane containing the triangle

        Vec3 intersectionPoint = Utility::LinePlaneIntersection(line, planeOfTriangle) 
                            -> finding the point of intersection between the infinte line and infinte plane

        bool result = Utility::PointInTriangleOrNot(trianglePoints, intersectionPoint) 
                            -> now checking whether the point is inside the triangle or not

        Utility::TextFileGenerator(line, trianglePoints, intersectionPoint) 
                            -> creating a file, whose content could be copy-pasted directly in desmos3D and viewed the result    
    </pre>

    <!-- Toggle button -->
    <button class="btn btn-primary" @onclick="ToggleDetailedCode">
        @(showDetailedCode ? "Hide Detailed Code" : "Show Detailed Code")
    </button>

    <!-- Detailed code snippet -->
    @if (showDetailedCode)
    {
        <pre class="code">
            ///////////////////////////////////////////
            ///////////////////////////////////////////

            // custom datatypes
            class Vec3{
                public:
                    float x, y, z;
                    Vec3();
                    Vec3(const float &X, const float &Y, const float &Z);
                    Vec3(const Vec3 &point);

                    Vec3 operator+(const Vec3 &b)const;
                    Vec3 operator-(const Vec3 &b)const;
                    Vec3 operator*(float &scalar)const;
                    float dot(const Vec3 &b)const;
                    Vec3 cross(const Vec3 &b) const;
            };
            struct Line{
                Vec3 origin;
                Vec3 direction;
            };
            struct Plane{
                Vec3 point;
                Vec3 normal;
            };

            // inputs
            Line line = {*(new Vec3(1,2,3)), *(new Vec3(4,1,2))};
            std::vector&lt;Vec3*&gt; trianglePoints = {
                new Vec3(1, 1, 3),
                new Vec3(6, 9, 2),
                new Vec3(5, 6, 7)
            };

            ////////////////////////////////////////////
            ////////////////////////////////////////////

            Plane planeOfTriangle = Utility::PlaneOfTriangle(trianglePoints) 
                            -> to find the plane containing the triangle

            Plane Utility::PlaneOfTriangle(const std::vector&lt;Vec3*&gt; &trianglePoints){
                // three pooints:p,q,r
                // vector pq, vector pr;
                Vec3 PQ = *trianglePoints[0] - *trianglePoints[1];
                Vec3 PR = *trianglePoints[0] - *trianglePoints[2];
                
                // cross prduct of above two vectors = normal of the plane;
                Vec3 normal = PQ.cross(PR);

                // return point on plane and normal of plane;
                return {*trianglePoints[0], normal};
            }


            ////////////////////////////////////////////
            ////////////////////////////////////////////

            Vec3 intersectionPoint = Utility::LinePlaneIntersection(line, planeOfTriangle) 
                            -> finding the point of intersection between the infinte line and infinte plane

            Vec3 Utility::LinePlaneIntersection(const Line &line, const Plane &plane)
            {
                Vec3 intersectionPoint(0,0,0);
                Vec3 planeNormal(plane.normal.x, plane.normal.y, plane.normal.z);
                Vec3 lineDir(line.direction.x, line.direction.y, line.direction.z);
                Vec3 lineOrigin(line.origin.x, line.origin.y, line.origin.z);
                Vec3 planePoint(plane.point.x, plane.point.y, plane.point.z);
                const float temp = planeNormal.dot(lineDir);
                if (temp > 0.001){
                    const Vec3 temp1 = planePoint - lineOrigin;
                    float t = planeNormal.dot(temp1);
                    t = t / temp;
                    intersectionPoint = lineOrigin +(lineDir*t);
                }
                else{
                    std::cout &lt;&lt; "Either both are parallel or collinear" &lt;&lt; std::endl;
                }
                return intersectionPoint;
            }


            ////////////////////////////////////////////
            ////////////////////////////////////////////


            bool result = Utility::PointInTriangleOrNot(trianglePoints, intersectionPoint) 
                            -> now checking whether the point is inside the triangle or not


            bool Utility::PointInTriangleOrNot(const std::vector&lt;Vec3*&gt; &trianglePoints, const Vec3 &point){
                float originalArea = CalculateTriangleArea(trianglePoints);
                // area method
                
                for (int i = 0; i &lt; trianglePoints.size();i++){
                    int i1 = i, i2 = i + 1;
                    i2 = (AreEqual(i2,trianglePoints.size())) ? 0 : i2;
                    std::vector &lt;Vec3*&gt; triangleWithAnotherPoint = {
                        new Vec3(point),
                        new Vec3(*trianglePoints[i1]),
                        new Vec3(*trianglePoints[i2])
                    };
                    float tempArea = CalculateTriangleArea(triangleWithAnotherPoint);
                    if ((tempArea-originalArea)&gt;0.001)
                    {
                        return false;
                    }
                }
                return true;
            }

            ////////////////////////////////////////////
            ////////////////////////////////////////////


            Utility::TextFileGenerator(line, trianglePoints, intersectionPoint) 
                            -> creating a file, whose content could be copy-pasted directly in desmos3D and viewed the result    
   
            
            void Utility::TextFileGenerator(const Line &line, const std::vector&lt;Vec3*&gt; &trianglePoints, const Vec3 &intersectionPoint){
                const std::string filePath = "../output.txt"; 
                std::ofstream outputFile(filePath);
                if (!outputFile.is_open()) {
                    std::cerr &lt;&lt; "Error opening the file!" &lt;&lt; std::endl;
                    return; // Return an error code
                }

                // line
                outputFile &lt;&lt; "\\ \\left("
                &lt;&lt;line.origin.x&lt;&lt;","&lt;&lt; line.origin.y&lt;&lt;","&lt;&lt;line.origin.z
                &lt;&lt;"\\right)+t\\left("&lt;&lt;
                line.direction.x&lt;&lt;","&lt;&lt;line.direction.y&lt;&lt;","&lt;&lt;line.direction.z
                &lt;&lt;"\\right)"&lt;&lt;std::endl;

                // plane
                // outputFile &lt;&lt; "4\\left(x-2\\right)+2\\left(y-5\\right)+8\\left(z-8\\right)=0" &lt;&lt; std::endl;

                // triangle
                outputFile &lt;&lt; "\\operatorname{triangle}\\left(\\left("
                &lt;&lt;trianglePoints[0]-&gt;x&lt;&lt;","&lt;&lt;trianglePoints[0]-&gt;y&lt;&lt;","&lt;&lt;trianglePoints[0]-&gt;z
                &lt;&lt;"\\right),\\left("
                &lt;&lt;trianglePoints[1]-&gt;x&lt;&lt;","&lt;&lt;trianglePoints[1]-&gt;y&lt;&lt;","&lt;&lt;trianglePoints[1]-&gt;z
                &lt;&lt;"\\right),\\left("
                &lt;&lt;trianglePoints[2]-&gt;x&lt;&lt;","&lt;&lt;trianglePoints[2]-&gt;y&lt;&lt;","&lt;&lt;trianglePoints[2]-&gt;z
                &lt;&lt;"\\right)\\right)" &lt;&lt; std::endl;

                // point of intersection
                outputFile &lt;&lt; "("
                &lt;&lt;intersectionPoint.x&lt;&lt;","&lt;&lt;intersectionPoint.y&lt;&lt;","&lt;&lt;intersectionPoint.z
                &lt;&lt;")" &lt;&lt; std::endl;

                // 4. Close the file
                outputFile.close();
                std::cout &lt;&lt; "Data successfully written to output.txt" &lt;&lt; std::endl;
            }
            ////////////////////////////////////////////
            ////////////////////////////////////////////
        </pre>
    }
</section>

@code {
    private bool showDetailedCode = false;

    private void ToggleDetailedCode()
    {
        showDetailedCode = !showDetailedCode;
    }
}
<section class="section">
    <h2>Source Code</h2>
    <p>
        You can explore the complete project on GitHub:
        <a href="https://github.com/Ojhaji000/computationalGeometry.git" target="_blank">
            View Repository
        </a>
    </p>
</section>


<!-- Architecture -->
<section class="section">
    <h2>Design & Architecture</h2>
    <ul>
        <li>
            The implementation follows a staged geometric pipeline: plane construction,
            line–plane intersection, and point-in-triangle classification.
        </li>
        <li>
            Custom data structures<strong>(Vec3,Plane,Line)</strong> are used to represent core geometric entities,
            keeping mathematical intent explicit and readable.
        </li>
        <li>
            Intersection and containment logic are intentionally decoupled to improve
            correctness, reuse, and testability.
        </li>
        <li>
            Visualization is handled via generated text output compatible with
            external tools<strong>(desmos3d)</strong>, ensuring the core geometry remains independent of rendering.
        </li>
    </ul>
</section>



<!-- Edge Cases -->
@* <section class="section">
    <h2>Precision & Coordinate Considerations</h2>
    <ul>
        <li>Floating-point precision errors</li>
        <li>Order of matrix multiplication</li>
        <li>Inverted Y-axis in screen coordinates</li>
    </ul>
</section> *@

<!-- Learnings -->
@* <section class="section">
    <h2>Learnings & Extensions</h2>
    <ul>
        <li>Matrix composition for multiple transformations</li>
        <li>Rotation and scaling using the same framework</li>
        <li>Porting the transformation logic to C++</li>
    </ul>
</section> *@
